import React, { useState, useEffect, useRef, useCallback } from 'react';

// ENUM vÉ™ TÄ°PLÆR
const TrafficLightState = { GREEN: 'green', YELLOW: 'yellow', RED: 'red' };

// Constants
const LOGICAL_WIDTH = 400;
const LOGICAL_HEIGHT = 600;
const CAR_WIDTH = 48;
const CAR_HEIGHT = 86;
const PLAYER_Y = LOGICAL_HEIGHT - 130;
const LANES = [100, 200, 300];
const PAYMENT_URL = "https://buymeacoffee.com/surwin";

// Motivational phrases
const MOTIVATIONAL_PHRASES = {
  az: ["MÃ¶htÉ™ÅŸÉ™m!", "SÉ™n bir peÅŸÉ™karsan!", "Yola davam!", "Æla sÃ¼rÃ¼rsÉ™n!", "BelÉ™ davam et!", "DiqqÉ™tli ol!", "SÃ¼kan arxasÄ±nda kalsan!"],
  en: ["Awesome!", "You're a pro!", "Keep going!", "Great driving!", "Stay focused!", "Master of the road!", "You got this!"],
};

// Biomes
const BIOMES = [
  { name: "City Streets", ground: "#0f172a", accent: "#334155" },
  { name: "Forest Road", ground: "#064e3b", accent: "#166534" },
  { name: "Canyon", ground: "#451a03", accent: "#92400e" }
];

// Car skins
const INITIAL_SKINS = [
  { id: 'classic', name: 'Classic Blue', color: '#3b82f6', price: 0, owned: true },
  { id: 'sport', name: 'Sport Red', color: '#ef4444', price: 5.0, owned: false },
  { id: 'taxi', name: 'Yellow Taxi', color: '#fbbf24', price: 8.0, owned: false },
  { id: 'noir', name: 'Premium Black', color: '#1e293b', price: 15.0, owned: false },
];

// Languages
const LANGUAGES = [
  { code: 'az', name: 'AzÉ™rbaycan', flag: 'ðŸ‡¦ðŸ‡¿', currency: 'AZN', rate: 1 },
  { code: 'en', name: 'English', flag: 'ðŸ‡¬ðŸ‡§', currency: 'USD', rate: 0.59 },
];

// Translations
const TRANSLATIONS = {
  az: { login: "GiriÅŸ", register: "Qeydiyyat", username: "Ä°stifadÉ™Ã§i adÄ±", password: "ÅžifrÉ™", remember: "Yadda saxla", noAcc: "Hesab yoxdur?", hasAcc: "Hesab var?", balance: "Balans", brake: "TORMOZ", braking: "DAYANIR...", garage: "QARAJ", topup: "ARTIR", gameOver: "OYUN BÄ°TDÄ°", balanceFinished: "Davam etmÉ™k Ã¼Ã§Ã¼n balans artÄ±rÄ±n.", restart: "YENÄ°DÆN", topUpHeading: "BALANSIN ARTIR", topUpText: "TÉ™hlÃ¼kÉ™siz Ã¶dÉ™niÅŸ Ã¼Ã§Ã¼n aÅŸaÄŸÄ±dakÄ± dÃ¼ymÉ™yÉ™ keÃ§id edin.", payStripe: "BalansÄ± ArtÄ±r (â˜•)", fine: "CÆRÄ°MÆ!", reward: "MÃœKAFAT!", crash: "QÆZA!", langHeading: "DÄ°L SEÃ‡Ä°N", adminMode: "Admin Rejimi" },
  en: { login: "Login", register: "Register", username: "Username", password: "Password", remember: "Remember", noAcc: "No account?", hasAcc: "Have account?", balance: "Balance", brake: "BRAKE", braking: "BRAKING...", garage: "GARAGE", topup: "ADD", gameOver: "GAME OVER", balanceFinished: "Top up to continue.", restart: "RESTART", topUpHeading: "RECHARGE BALANCE", topUpText: "Follow the link below for secure payment.", payStripe: "Top Up Now (â˜•)", fine: "FINE!", reward: "REWARD!", crash: "CRASH!", langHeading: "LANGUAGE", adminMode: "Admin Mode" },
};

// Base64 decode
const decodeBase64 = (base64) => {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
  return bytes;
};

// Audio decode
const decodeAudioData = async (data, ctx, sampleRate, numChannels) => {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);
  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
  }
  return buffer;
};

// Main App
const App = () => {
  const [currentUser, setCurrentUser] = useState(() => localStorage.getItem("activeUser"));
  const [authMode, setAuthMode] = useState('login');
  const [authForm, setAuthForm] = useState({ username: '', password: '' });
  const [balance, setBalance] = useState(() => parseFloat(localStorage.getItem("balance") || "0.30"));
  const [level, setLevel] = useState(1);
  const [lang, setLang] = useState(() => localStorage.getItem("gameLang") || 'az');
  const [isBraking, setIsBraking] = useState(false);
  const [feedback, setFeedback] = useState(null);
  const [isGameOver, setIsGameOver] = useState(false);
  const [showGarage, setShowGarage] = useState(false);
  const [showTopUp, setShowTopUp] = useState(false);
  const [showLang, setShowLang] = useState(false);
  const [skins, setSkins] = useState(INITIAL_SKINS);
  const [activeSkinId, setActiveSkinId] = useState('classic');
  const [biomeIdx, setBiomeIdx] = useState(0);
  const [flashRed, setFlashRed] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);

  const t = TRANSLATIONS[lang] || TRANSLATIONS['en'];
  const currentLangData = LANGUAGES.find(l => l.code === lang) || LANGUAGES[0];

  const audioCtxRef = useRef(null);
  const engineOscRef = useRef(null);
  const engineGainRef = useRef(null);
  const balanceRef = useRef(balance);
  const isAdminRef = useRef(isAdmin);

  useEffect(() => { balanceRef.current = balance; localStorage.setItem("balance", balance.toFixed(2)); }, [balance]);
  useEffect(() => { localStorage.setItem("gameLang", lang); }, [lang]);
  useEffect(() => { isAdminRef.current = isAdmin; }, [isAdmin]);

  const initAudio = () => {
    if (audioCtxRef.current) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    audioCtxRef.current = ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(40, ctx.currentTime);
    gain.gain.setValueAtTime(0, ctx.currentTime);
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(150, ctx.currentTime);
    osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);
    osc.start();
    engineOscRef.current = osc; engineGainRef.current = gain;
  };

  const playSound = (type) => {
    const ctx = audioCtxRef.current; if (!ctx) return;
    const osc = ctx.createOscillator(); const gain = ctx.createGain();
    if(type==='crash'){osc.type='triangle'; osc.frequency.setValueAtTime(150, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime+0.3); gain.gain.setValueAtTime(0.3, ctx.currentTime); gain.gain.linearRampToValueAtTime(0, ctx.currentTime+0.4);}
    else {osc.type='sine'; osc.frequency.setValueAtTime(type==='point'?600:200, ctx.currentTime); gain.gain.setValueAtTime(0.1, ctx.currentTime); gain.gain.linearRampToValueAtTime(0, ctx.currentTime+0.2);}
    osc.connect(gain); gain.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime+0.4);
  };

  const triggerFeedback = (text, type) => {
    setFeedback({ text, type });
    if(type==='error'){setFlashRed(true); setTimeout(()=>setFlashRed(false),200); playSound('crash');}
    else if(type==='success') playSound('point');
    setTimeout(()=>setFeedback(null),3000);
  };

  const canvasRef = useRef(null);
  const gameStateRef = useRef({ carX: LANES[1]-CAR_WIDTH/2, targetX: LANES[1]-CAR_WIDTH/2, stopLineY: -200, trafficLight: TrafficLightState.GREEN, timer: 0, linesOffset:0, isBraking:false, traffic:[], scenery:[], totalDistance:0, idCounter:0, levelPassed:false, fineTimer:0 });

  const update = useCallback(()=>{
    if(!currentUser || showGarage || showTopUp || showLang || isGameOver) return;
    const state = gameStateRef.current;
    if(!isAdminRef.current && balanceRef.current<=0){setIsGameOver(true); return;}
    const speed = 4+(level*0.5); const currentMoveSpeed = state.isBraking?0:speed;
    state.linesOffset=(state.linesOffset+currentMoveSpeed)%80; state.totalDistance+=currentMoveSpeed;
    state.carX += (state.targetX-state.carX)*0.15;
    state.timer++; if(state.timer<300) state.trafficLight=TrafficLightState.GREEN;
    else if(state.timer<450) state.trafficLight=TrafficLightState.YELLOW;
    else if(state.timer<950) state.trafficLight=TrafficLightState.RED;
    else state.timer=0;
  }, [currentUser, showGarage, showTopUp, showLang, isGameOver, level]);

  const drawCar=(ctx,x,y,color,braking)=>{ctx.save(); ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(x+CAR_WIDTH/2,y+CAR_HEIGHT/2+4,CAR_WIDTH/2+2,CAR_HEIGHT/2+2,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle=color; ctx.beginPath(); ctx.fillRect(x,y,CAR_WIDTH,CAR_HEIGHT); ctx.fillStyle=braking?'#ef4444':'#7f1d1d'; ctx.fillRect(x+6,y+CAR_HEIGHT-6,10,4); ctx.fillRect(x+CAR_WIDTH-16,y+CAR_HEIGHT-6,10,4); ctx.restore(); };

  const draw = useCallback(()=>{
    if(!currentUser) return;
    const canvas=canvasRef.current; if(!canvas) return; const ctx=canvas.getContext('2d'); if(!ctx) return;
    const state=gameStateRef.current; const biome=BIOMES[biomeIdx];
    ctx.clearRect(0,0,LOGICAL_WIDTH,LOGICAL_HEIGHT);
    ctx.fillStyle=biome.ground; ctx.fillRect(0,0,LOGICAL_WIDTH,LOGICAL_HEIGHT);
    drawCar(ctx,state.carX,PLAYER_Y,skins.find(s=>s.id===activeSkinId).color,isBraking);
  },[currentUser, activeSkinId, skins, biomeIdx,isBraking]);

  useEffect(()=>{let frame; const loop=()=>{update(); draw(); frame=requestAnimationFrame(loop);}; frame=requestAnimationFrame(loop); return ()=>cancelAnimationFrame(frame);},[update,draw]);

  const handleAuth=()=>{if(!authForm.username||!authForm.password) return; initAudio(); localStorage.setItem("u_"+authForm.username,authForm.password); localStorage.setItem("activeUser",authForm.username); setCurrentUser(authForm.username);};
  const reset=()=>{setLevel(1); setIsGameOver(false); gameStateRef.current.traffic=[]; gameStateRef.current.stopLineY=-200; initAudio();};

  if(!currentUser) return (
    <div className="flex h-[100vh] bg-[#0f172a] items-center justify-center p-8" onMouseDown={initAudio}>
      <div className="w-full max-w-sm bg-slate-800 border border-white/5 rounded-3xl p-10 shadow-2xl overflow-hidden">
        <h2 className="text-3xl font-black text-white italic mb-8 uppercase text-center">{authMode==='login'?t.login:t.register}</h2>
        <div className="space-y-4">
          <input type="text" placeholder={t.username} className="w-full bg-slate-900 border border-white/5 p-4 rounded-xl text-white outline-none" onChange={e=>setAuthForm({...authForm,username:e.target.value})} />
          <input type="password" placeholder={t.password} className="w-full bg-slate-900 border border-white/5 p-4 rounded-xl text-white outline-none" onChange={e=>setAuthForm({...authForm,password:e.target.value})} />
          <button onClick={handleAuth} className="w-full py-4 bg-cyan-600 rounded-xl text-white font-black uppercase tracking-widest">{authMode==='login'?t.login:t.register}</button>
        </div>
      </div>
    </div>
  );

  return (
    <div className={`flex flex-col h-[100vh] bg-[#0f172a] text-white overflow-hidden transition-colors ${flashRed?'bg-rose-950':''}`} onMouseDown={initAudio}>
      <canvas ref={canvasRef} width={LOGICAL_WIDTH} height={LOGICAL_HEIGHT} className="w-full h-full object-contain" />
    </div>
  );
};

export default App;
